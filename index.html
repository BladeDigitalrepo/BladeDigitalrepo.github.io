<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Hex Run Arcade v12</title>
  <style>
    body {
      margin: 0;
      background: black;
      color: white;
      font-family: monospace;
      overflow: hidden;
    }
    canvas {
      display: block;
      margin: auto;
      background: black;
      touch-action: none;
    }
    /* Controls sit just under the 400px canvas */
    #controls {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      z-index: 5;
    }
    .btn {
      background: black;
      border: 2px solid cyan;
      color: cyan;
      font-size: 16px;
      font-family: monospace;
      padding: 10px 20px;
      border-radius: 10px;
      text-align: center;
      user-select: none;
      cursor: pointer;
      box-shadow: 0 0 10px cyan;
    }
    .btn:active { background: cyan; color: black; }
    #btnRestart { display: none; border-color: magenta; color: magenta; box-shadow: 0 0 10px magenta; }
    #btnRestart:active { background: magenta; color: black; }

    #startScreen {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: black; color: cyan;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      text-align: center; z-index: 10;
    }
    #startScreen h1 { font-size: 40px; text-shadow: 0 0 20px magenta, 0 0 10px cyan; }
    #startScreen pre { color: cyan; text-shadow: 0 0 5px cyan; }
    #btnStart {
      margin-top: 20px; background: black; border: 2px solid magenta; color: magenta;
      padding: 10px 30px; font-size: 20px; font-family: monospace; border-radius: 10px;
      cursor: pointer; box-shadow: 0 0 10px magenta;
    }
    #btnStart:active { background: magenta; color: black; }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="390"></canvas>

  <!-- Arcade Start Screen -->
  <div id="startScreen">
    <h1>HEX RUN ARCADE</h1>
    <pre>
     /\_/\
    ‚ö°=^.^=
    </pre>
    <button id="btnStart">‚ñ∂ START</button>
  </div>

  <!-- Touch controls -->
  <div id="controls">
    <div class="btn" id="btnLeft">‚¨ÖÔ∏è</div>
    <div class="btn" id="btnJump">‚§¥Ô∏è JUMP</div>
    <div class="btn" id="btnDuck">‚§µÔ∏è DUCK</div>
    <div class="btn" id="btnRight">‚û°Ô∏è</div>
    <div class="btn" id="btnPause">‚è∏Ô∏è</div>
    <div class="btn" id="btnRestart">üîÑ Restart</div>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // ---------- Audio ----------
    const jumpSound  = new Audio("https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg");
    const scoreSound = new Audio("https://actions.google.com/sounds/v1/cartoon/slide_whistle_to_drum.ogg");
    const crashSound = new Audio("https://actions.google.com/sounds/v1/cartoon/concussive_drum_hit.ogg");
    const bgMusic    = new Audio("https://vgmsite.com/soundtracks/pokemon-gameboy-sound-collection/jhbtfxzdfp/101%20-%20Opening.mp3");
    bgMusic.loop = true; bgMusic.volume = 0.4;

    function playSound(a) {
      a.currentTime = 0;
      a.play().catch(()=>{ /* mobile may block until tap; handled by START */ });
    }

    // ---------- Game state ----------
    let running = false, paused = false;
    let speed = 4, gravity = 0.6, jumpStrength = -12, score = 0;

    // Player "physics" origin is top-left of standing cat sprite
    const CAT_W = 64;               // visual/collision width
    const CAT_H_STAND = 64;         // 4 lines * 16px
    const CAT_H_DUCK  = 48;         // 3 lines * 16px
    const GROUND_Y = 300;           // top of cat when on ground (standing)
    const player = { x: 100, y: GROUND_Y, dy: 0, jumping: false, ducking: false };

    // Obstacles & drones
    const obstacles = [], drones = [];
    let droneCooldown = 0;          // forces spacing between drones

    // Background
    const stars = [];
    for (let i=0;i<100;i++) stars.push({ x: Math.random()*canvas.width, y: Math.random()*canvas.height, r: Math.random()*2 });

    const skyline = [];
    function generateSkyline() {
      skyline.length = 0;
      let x = 0;
      while (x < canvas.width + 100) {
        const w = 40 + Math.random()*30;
        const h = 80 + Math.random()*120;
        skyline.push({ x, w, h });
        x += w;
      }
    }
    generateSkyline();

    // ---------- Cyber Cat frames ----------
    const catRunFrames = [
      ["   /\\_/\\ ", "‚ö°Ô∏è„Ää=^.^=)", "   /|_|\\ ", "   / | \\"],  // legs spread
      ["   /\\_/\\ ", "‚ö°Ô∏è„Ää=^.^=)", "   /|_|\\ ", "   /   \\"]   // legs together
    ];
    const catDuckFrame = ["   /\\_/\\ ", "‚ö°Ô∏è„Ää=^.^=)", "   /_/\\_\\ "];

    let frameIndex = 0, frameCounter = 0;

    function drawCat(x, y, ducking=false) {
      ctx.shadowBlur = 15; ctx.shadowColor = "cyan"; ctx.fillStyle = "cyan"; ctx.font = "16px monospace";

      let lines;
      let yOffset = 0;
      if (ducking) {
        lines = catDuckFrame;
        // keep cat's feet on ground: lower the drawing so bottom stays aligned
        yOffset = CAT_H_STAND - CAT_H_DUCK; // draw lower
      } else {
        // animate legs every 10 frames
        frameCounter++; if (frameCounter % 10 === 0) frameIndex = (frameIndex + 1) % catRunFrames.length;
        lines = catRunFrames[frameIndex];
      }

      for (let i=0;i<lines.length;i++) ctx.fillText(lines[i], x, y + yOffset + i*16);
      ctx.shadowBlur = 0;
    }

    // Compute hitbox anchored to cat's feet (so duck lowers top)
    function getCatHitbox() {
      const bottom = player.y + CAT_H_STAND;
      const h = player.ducking ? CAT_H_DUCK : CAT_H_STAND;
      return { x: player.x, y: bottom - h, w: CAT_W, h };
    }

    // ---------- Input ----------
    function jump() {
      if (!player.jumping && !player.ducking && running && !paused) {
        player.dy = jumpStrength; player.jumping = true; playSound(jumpSound);
      }
    }
    function setDuck(state) {
      if (!running || paused) return;
      // only allow duck on ground
      if (player.jumping && state) return;
      player.ducking = !!state;
    }

    // Keyboard
    document.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      if (k === "arrowup" || k === "w") jump();
      if (k === "arrowleft" || k === "a") { if (speed > 1) speed -= 1; }
      if (k === "arrowright"|| k === "d") { speed += 1; }
      if (k === "p") { paused = !paused; if (paused) bgMusic.pause(); else playSound(bgMusic); }
      if (k === "arrowdown" || k === "s") setDuck(true);
      if (k === "r" && !running) doRestart();
    });
    document.addEventListener("keyup", (e) => {
      const k = e.key.toLowerCase();
      if (k === "arrowdown" || k === "s") setDuck(false);
    });

    // Buttons
    const btnRestart = document.getElementById("btnRestart");
    document.getElementById("btnStart").addEventListener("click", () => {
      document.getElementById("startScreen").style.display = "none";
      resetGame(); running = true; playSound(bgMusic); requestAnimationFrame(gameLoop);
    });
    document.getElementById("btnJump").addEventListener("click", jump);
    document.getElementById("btnLeft").addEventListener("click", () => { if (speed > 1) speed -= 1; });
    document.getElementById("btnRight").addEventListener("click", () => { speed += 1; });
    document.getElementById("btnPause").addEventListener("click", () => {
      paused = !paused; if (paused) bgMusic.pause(); else playSound(bgMusic);
      if (!paused && running) requestAnimationFrame(gameLoop);
    });

    // Duck button supports hold-to-duck on touch
    const btnDuck = document.getElementById("btnDuck");
    btnDuck.addEventListener("mousedown",  () => setDuck(true));
    btnDuck.addEventListener("mouseup",    () => setDuck(false));
    btnDuck.addEventListener("mouseleave", () => setDuck(false));
    btnDuck.addEventListener("touchstart", (e)=>{ e.preventDefault(); setDuck(true); }, {passive:false});
    btnDuck.addEventListener("touchend",   (e)=>{ e.preventDefault(); setDuck(false); }, {passive:false});

    btnRestart.addEventListener("click", () => doRestart());

    function doRestart() {
      resetGame();
      btnRestart.style.display = "none";
      playSound(bgMusic);
      requestAnimationFrame(gameLoop);
    }

    // ---------- Core loop helpers ----------
    function resetGame() {
      obstacles.length = 0; drones.length = 0; droneCooldown = 0;
      generateSkyline();
      score = 0; speed = 4;
      player.y = GROUND_Y; player.dy = 0; player.jumping = false; player.ducking = false;
      running = true; paused = false;
      btnRestart.style.display = "none";
    }

    function update() {
      if (paused) return;

      // Gravity / ground
      player.y += player.dy; player.dy += gravity;
      if (player.y > GROUND_Y) { player.y = GROUND_Y; player.dy = 0; player.jumping = false; }

      // Move obstacles
      obstacles.forEach(o => o.x -= speed);
      if (obstacles.length && obstacles[0].x + 20 < 0) { obstacles.shift(); score++; playSound(scoreSound); }

      // Move drones
      drones.forEach(d => d.x -= speed);
      if (drones.length && drones[0].x + 20 < 0) { drones.shift(); score++; playSound(scoreSound); }

      // Collisions (AABB vs cat hitbox)
      const hb = getCatHitbox();
      const collidesRect = (rx, ry, rw, rh) => (
        hb.x < rx + rw && hb.x + hb.w > rx &&
        hb.y < ry + rh && hb.y + hb.h > ry
      );
      // walls
      for (const o of obstacles) { if (collidesRect(o.x, o.y, 20, 40)) gameOver(); }
      // drones (20x20 circle approximated as square)
      for (const d of drones)    { if (collidesRect(d.x, d.y, 20, 20)) gameOver(); }

      // Spawns
      if (Math.random() < 0.02) obstacles.push({ x: canvas.width, y: 320 });
      if (droneCooldown <= 0 && Math.random() < 0.02) {
        drones.push({ x: canvas.width, y: 200 + Math.random()*100 - 50 });
        droneCooldown = 200; // ~200 frames spacing
      } else {
        droneCooldown--;
      }

      // Skyline parallax
      skyline.forEach(b => b.x -= speed * 0.5);
      if (skyline.length && skyline[0].x + skyline[0].w < 0) {
        const lastX = skyline[skyline.length-1].x + skyline[skyline.length-1].w;
        skyline.shift();
        skyline.push({ x: lastX, w: 40 + Math.random()*30, h: 80 + Math.random()*120 });
      }

      // Difficulty
      if (score % 10 === 0 && score !== 0 && speed < 12) speed += 0.02;
    }

    function gameOver() {
      if (!running) return;
      running = false;
      playSound(crashSound);
      bgMusic.pause();
      btnRestart.style.display = "block";
    }

    // ---------- Drawing ----------
    function drawSkyline() {
      ctx.shadowBlur = 15; ctx.shadowColor = "magenta"; ctx.fillStyle = "#111";
      skyline.forEach(b => {
        ctx.fillRect(b.x, canvas.height - b.h - 60, b.w, b.h);
        ctx.strokeStyle = "magenta"; ctx.strokeRect(b.x, canvas.height - b.h - 60, b.w, b.h);
      });
      ctx.shadowBlur = 0;
    }

    function draw() {
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // Stars
      ctx.fillStyle = "white";
      stars.forEach(s => { ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill(); s.x -= 0.2; if (s.x < 0) s.x = canvas.width; });

      // Skyline
      drawSkyline();

      // Ground
      ctx.fillStyle = "lime"; ctx.fillRect(0,340,canvas.width,5);

      // Cat
      drawCat(player.x, player.y, player.ducking);

      // Obstacles
      ctx.shadowBlur = 10; ctx.shadowColor = "red"; ctx.fillStyle = "red";
      obstacles.forEach(o => ctx.fillRect(o.x, o.y, 20, 40)); ctx.shadowBlur = 0;

      // Drones
      ctx.shadowBlur = 10; ctx.shadowColor = "orange"; ctx.fillStyle = "orange";
      drones.forEach(d => { ctx.beginPath(); ctx.arc(d.x+10, d.y+10, 10, 0, Math.PI*2); ctx.fill(); }); ctx.shadowBlur = 0;

      // HUD
      ctx.fillStyle = "white"; ctx.font = "16px monospace";
      ctx.fillText("Score: " + score, 10, 20);
      ctx.fillText("Speed: " + speed.toFixed(1), 10, 40);

      if (!running) {
        ctx.fillStyle = "white"; ctx.font = "24px monospace";
        ctx.fillText("üíÄ GAME OVER üíÄ", canvas.width/2 - 100, canvas.height/2);
        ctx.fillText("Final Score: " + score, canvas.width/2 - 90, canvas.height/2 + 40);
      }
      if (paused && running) {
        ctx.fillStyle = "white"; ctx.font = "20px monospace";
        ctx.fillText("‚è∏ PAUSED", canvas.width/2 - 50, canvas.height/2);
      }
    }

    // ---------- Loop ----------
    function gameLoop() {
      if (!running) { draw(); return; }
      update(); draw(); requestAnimationFrame(gameLoop);
    }
  </script>
</body>
</html>
